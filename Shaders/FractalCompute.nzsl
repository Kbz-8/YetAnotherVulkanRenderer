[nzsl_version("1.0")]
module;

const workgroup_size = vec3[u32](u32(64), u32(1), u32(1));
const iterations = 3;

[layout(std430)]
struct SSBO
{
	vertices: dyn_array[vec3[f32]]
}

external
{
	[set(0), binding(0)] ssbo: storage[SSBO]
}

struct Input
{
	[builtin(global_invocation_indices)] indices: vec3[u32]
}

[entry(compute)]
[workgroup(workgroup_size.x, workgroup_size.y, workgroup_size.z)]
fn main(input : Input)
{
	let global_index : u32 = input.indices.x + input.indices.y * workgroup_size.x + input.indices.z * workgroup_size.x * workgroup_size.y;
	let cube_pos : vec3[f32] = vec3[f32](input.indices) / vec3[f32](workgroup_size);

	for i in 0 -> iterations
	{
		// Subdivide the cube into 27 smaller cubes
		for x in 0 -> 3
		{
			for y in 0 -> 3
			{
				for z in 0 -> 3
				{
					let sub_cube_pos : vec3[f32] = cube_pos + vec3[f32](f32(x), f32(y), f32(z)) / 3.0;

					// Check if this subcube is not the center cube or one of the six cubes that share a face with the center
					if(!(x == 1 && y == 1 && z == 1) && !(x == 0 && y == 1 && z == 1) && !(x == 2 && y == 1 && z == 1) &&
						!(x == 1 && y == 0 && z == 1) && !(x == 1 && y == 2 && z == 1) && !(x == 1 && y == 1 && z == 0) &&
						!(x == 1 && y == 1 && z == 2))
					{
						ssbo.vertices[global_index] = sub_cube_pos;
						global_index += u32(1);
					}
				}
			}
		}
	}
}
